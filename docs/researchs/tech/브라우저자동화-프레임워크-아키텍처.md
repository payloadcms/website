# CareOn 브라우저 자동화 프레임워크 아키텍처 딥리서치

Stagehand의 TypeScript 프리미티브와 Skyvern의 에이전트 구조를 결합하고, **Qwen2.5-VL 비전 모델**로 DOM 기반 한계를 보완하며, **Playwright MCP**로 AI 직접 제어를 구현하는 하이브리드 아키텍처가 CareOn의 최적 솔루션입니다. 로컬 LLM(Ollama)과 클라우드 API 폴백을 통해 비용을 **80% 절감**하면서 프로덕션급 안정성을 확보할 수 있습니다.

---

## 통합 아키텍처 개요

CareOn의 네이버 블로그 자동화 시스템은 4개 레이어로 구성됩니다. 최상위 **워크플로우 빌더 UI**에서 사용자가 시각적으로 자동화 시나리오를 구성하면, **오케스트레이션 레이어**가 Atomic Block들을 순차 실행합니다. 각 블록은 **하이브리드 LLM 레이어**를 통해 의사결정을 수행하고, 최하위 **브라우저 제어 레이어**가 실제 브라우저 조작을 담당합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        사용자 인터페이스 레이어                                │
│  ┌──────────────────┐  ┌─────────────────┐  ┌────────────────────────────┐  │
│  │  React Flow      │  │ 템플릿 라이브러리  │  │ 자연어 → 워크플로우 변환     │  │
│  │  워크플로우 빌더   │  │ (네이버 블로그용)  │  │ (GPT-4o 기반)               │  │
│  └────────┬─────────┘  └────────┬────────┘  └──────────────┬─────────────┘  │
└───────────┼─────────────────────┼──────────────────────────┼────────────────┘
            │                     │                          │
            ▼                     ▼                          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        오케스트레이션 레이어                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │              Skyvern 스타일 Multi-Agent Orchestrator                │   │
│  │   ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────────┐    │   │
│  │   │ Planner  │──▶│  Actor   │──▶│Validator │──▶│   Recovery   │    │   │
│  │   │  Agent   │   │  Agent   │   │  Agent   │   │    Agent     │    │   │
│  │   └──────────┘   └──────────┘   └──────────┘   └──────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Atomic Block Registry (15개)                     │   │
│  │  CDP연결 │ 네이버접속 │ 로그인 │ 본문입력 │ 이미지업로드 │ 발행 │ ...  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
            │                                               │
            ▼                                               ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         하이브리드 LLM 레이어                                │
│  ┌─────────────────────────┐    ┌──────────────────────────────────────┐   │
│  │      DOM 분석 경로       │    │         Vision 분석 경로              │   │
│  │  ┌───────────────────┐  │    │  ┌─────────────────────────────────┐│   │
│  │  │  Stagehand 3.0    │  │    │  │     Qwen2.5-VL-7B (Ollama)      ││   │
│  │  │  act()/extract()  │  │    │  │  Screenshot → 좌표추출 → 클릭    ││   │
│  │  │  observe() 캐싱   │  │    │  │  한국어 OCR 95%+ 정확도          ││   │
│  │  └───────────────────┘  │    │  └─────────────────────────────────┘│   │
│  └────────────┬────────────┘    └────────────────┬─────────────────────┘   │
│               │                                   │                         │
│               ▼                                   ▼                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Fallback Chain Router                            │   │
│  │   Qwen2.5-7B(로컬) → Claude Sonnet 4 → GPT-4o (비용순 라우팅)        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
            │
            ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        브라우저 제어 레이어                                   │
│  ┌─────────────────────────┐    ┌──────────────────────────────────────┐   │
│  │    Playwright MCP       │    │      Browser Pool Manager            │   │
│  │  - AI 직접 브라우저 제어  │    │  - 계정별 격리된 Context             │   │
│  │  - Accessibility Tree   │    │  - 세션 영속성 (StorageState)        │   │
│  │  - 26+ 자동화 도구       │    │  - 프록시 풀 + IP 로테이션           │   │
│  └─────────────────────────┘    └──────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Stagehand 3.0 핵심 기능과 한계

Stagehand v3는 Playwright 의존성을 제거하고 **CDP(Chrome DevTools Protocol) 직접 통신**으로 전환하여 **44% 성능 향상**을 달성했습니다. act(), extract(), observe() 세 가지 프리미티브가 핵심이며, **Accessibility Tree 기반** DOM 분석으로 LLM에 최적화된 컨텍스트를 생성합니다.

**act() 프리미티브**는 자연어 명령을 브라우저 액션으로 변환합니다. "로그인 버튼 클릭"이라는 명령을 받으면 DOM을 크롤링하여 후보 요소 목록을 생성하고, XPath를 추출한 뒤 LLM이 Playwright 구문의 액션 메서드를 반환합니다. **extract()**는 Zod 스키마 기반으로 페이지 데이터를 구조화된 타입으로 추출하며, **observe()**는 현재 페이지에서 실행 가능한 액션들을 미리 발견하여 캐싱합니다.

```typescript
// Stagehand 캐싱 패턴 - LLM 호출 최소화
const [actionPreview] = await page.observe("네이버 로그인 버튼 찾기");
// Returns: { selector: "/html/body/div[1]/a", method: "click" }

await page.act(actionPreview);  // LLM 호출 없이 캐시된 셀렉터로 즉시 실행
```

**Self-healing 메커니즘**은 캐시된 셀렉터가 실패할 때 자동으로 새로운 스크린샷/Accessibility Tree를 캡처하고 LLM을 재호출하여 복구합니다. 그러나 **v3에서 Vision 기능이 deprecated**되었으며, 이는 이미지 기반 UI나 Canvas 요소 처리에 한계를 야기합니다.

---

## Skyvern의 에이전트 아키텍처 적용

Skyvern은 **Planner-Actor-Validator** 멀티 에이전트 루프를 통해 복잡한 웹 자동화를 안정적으로 수행합니다. Planner Agent가 목표를 세부 단계로 분해하고, Actor Agent가 Vision LLM 가이드 하에 브라우저 액션을 실행하며, Validator Agent가 각 단계의 성공 여부를 검증합니다.

CareOn에 적용할 **Atomic Block 시스템** 설계는 다음과 같습니다:

| 블록 카테고리 | 블록 타입 | 설명 |
|--------------|----------|------|
| **Navigation** | goToUrl, click, type, scroll | 기본 브라우저 조작 |
| **Data** | extractText, extractTable, screenshot | 데이터 추출 |
| **Control Flow** | condition, loop, wait, waitForElement | 흐름 제어 |
| **AI** | aiPrompt, aiVisionAnalyze, aiDecide | LLM 기반 의사결정 |
| **Naver Specific** | naverLogin, blogWrite, imageUpload, publish | 네이버 특화 블록 |

각 블록은 **YAML/JSON으로 직렬화** 가능하며, 워크플로우 빌더에서 드래그-앤-드롭으로 연결됩니다:

```yaml
workflow:
  name: "네이버 블로그 자동 발행"
  blocks:
    - type: naverLogin
      credential_id: "{{account_credential}}"
      totp_secret: "{{2fa_secret}}"
      
    - type: navigation
      url: "https://blog.naver.com/{{blog_id}}/postwrite"
      
    - type: aiPrompt
      prompt: "본문 에디터에 {{content}}를 입력하세요"
      
    - type: imageUpload
      files: "{{image_paths}}"
      
    - type: click
      selector: "#publish-button"
      human_delay: true
```

---

## Vision LLM 통합으로 DOM 한계 극복

Stagehand의 DOM 기반 접근법은 **Canvas, 이미지 버튼, 동적 UI**에서 실패합니다. **Qwen2.5-VL-7B**를 Ollama로 로컬 배포하여 이 한계를 극복합니다. Qwen2.5-VL은 **32개 언어 OCR 지원**(한국어 포함)과 **네이티브 바운딩박스 좌표 출력**을 제공하며, 8GB VRAM으로 구동 가능합니다.

**Screenshot → Vision LLM → Action 파이프라인** 구현:

```typescript
class VisionAutomationPipeline {
  private visionModel = "qwen2.5vl:7b";
  
  async analyzeAndClick(page: Page, instruction: string): Promise<boolean> {
    // 1. 스크린샷 캡처
    const screenshot = await page.screenshot({ type: 'png' });
    
    // 2. Qwen2.5-VL로 좌표 추출
    const response = await ollama.generate({
      model: this.visionModel,
      prompt: `당신은 네이버 웹사이트 자동화 에이전트입니다.
        스크린샷을 분석하고 다음 작업을 수행하세요: ${instruction}
        
        클릭해야 할 요소의 좌표를 JSON으로 반환하세요:
        {"found": true/false, "element": "요소 설명", "bbox": [x1, y1, x2, y2], "click_point": [cx, cy]}`,
      images: [screenshot],
      format: "json"
    });
    
    const result = JSON.parse(response.response);
    
    // 3. 좌표 기반 클릭 실행
    if (result.found && result.click_point) {
      const [cx, cy] = result.click_point;
      await page.mouse.click(cx, cy);
      return true;
    }
    return false;
  }
}
```

**OmniParser V2** 전처리를 추가하면 정확도가 **0.8%에서 39.6%로 향상**됩니다. OmniParser가 인터랙티브 요소를 사전 감지하고 라벨링하면, Vision LLM은 더 정확한 타겟 선택이 가능합니다.

---

## 하이브리드 LLM 라우팅으로 비용 80% 절감

**도메인 특화 작업(네이버 블로그)**은 로컬 LLM으로, **복잡한 추론**은 클라우드 API로 라우팅하는 전략입니다.

```typescript
class HybridLLMRouter {
  private routingRules = {
    // 네이버 도메인 → 100% 로컬
    naverDomain: (task: Task) => task.url?.includes('naver.com'),
    
    // 단순 네비게이션 → 로컬 우선, 폴백 클라우드
    simpleNavigation: (task: Task) => task.tokens < 500,
    
    // 복잡 추론 → 클라우드 직행
    complexReasoning: (task: Task) => 
      /분석|비교|요약|결정/.test(task.description)
  };

  route(task: Task): 'local' | 'cloud' | 'hybrid' {
    if (this.routingRules.naverDomain(task)) return 'local';
    if (this.routingRules.complexReasoning(task)) return 'cloud';
    return 'hybrid';  // 로컬 시도 → 실패 시 클라우드
  }
}
```

**월간 비용 분석** (10,000 자동화 태스크 기준):

| 접근법 | 클라우드 토큰 | 월간 비용 |
|--------|-------------|----------|
| 클라우드 전용 (GPT-4o) | 25M | ~$150 |
| 클라우드 전용 (Claude) | 25M | ~$90 |
| **하이브리드 (80% 로컬)** | 5M | **~$25 + GPU 전기료** |

Fallback Chain은 **Qwen2.5-7B(로컬) → Claude Sonnet 4 → GPT-4o** 순서로 구성합니다. 각 단계에서 타임아웃(10초)이나 오류 발생 시 자동으로 다음 모델로 전환됩니다.

---

## MCP 통합으로 AI 직접 브라우저 제어

**Microsoft Playwright MCP**를 권장합니다. Chrome DevTools MCP 대비 **크로스 브라우저 지원**, **Accessibility Tree 기반** 안정적 요소 식별, **Docker 공식 지원**의 장점이 있습니다.

```json
// Claude Desktop 또는 커스텀 AI 에이전트 MCP 설정
{
  "mcpServers": {
    "careon-browser": {
      "command": "npx",
      "args": [
        "@playwright/mcp@latest",
        "--browser", "chromium",
        "--headless",
        "--isolated",
        "--storage-state", "./sessions/naver-auth.json",
        "--caps", "core,vision,pdf"
      ]
    }
  }
}
```

MCP를 통해 AI 에이전트는 `browser_click`, `browser_type`, `browser_navigate`, `browser_snapshot` 등 **26개 이상의 도구**에 직접 접근합니다. CareOn 오케스트레이터가 MCP 클라이언트로 동작하며, 각 Atomic Block 실행 시 MCP 서버를 통해 브라우저를 제어합니다.

---

## 프로덕션 아키텍처 핵심 패턴

**다중 계정 병렬 처리**는 Browser Pool 패턴으로 구현합니다. 각 네이버 계정은 격리된 Browser Context에서 실행되며, Playwright의 StorageState로 세션을 영속화합니다.

```typescript
class BrowserPool {
  async acquire(accountId: string) {
    const context = await browser.newContext({
      storageState: `./sessions/${accountId}.json`,
      proxy: this.proxyManager.getProxy(accountId)
    });
    
    // 봇 탐지 회피 스크립트 주입
    await context.addInitScript(() => {
      Object.defineProperty(navigator, 'webdriver', { get: () => false });
    });
    
    return context;
  }
}
```

**봇 탐지 회피 전략**:
- **가우시안 분포 딜레이**: 평균 100ms, 표준편차 30ms의 타이핑 간격
- **베지어 곡선 마우스 이동**: 직선이 아닌 자연스러운 커서 경로
- **한국 주거용 프록시**: 데이터센터 IP는 차단율이 높음
- **계정별 고정 핑거프린트**: 동일 계정은 일관된 User-Agent, 뷰포트 유지

**에러 복구**는 **Exponential Backoff + Circuit Breaker** 조합입니다. 5회 연속 실패 시 Circuit이 OPEN 상태로 전환되어 30초간 해당 계정의 요청을 차단합니다.

---

## 비주얼 워크플로우 빌더 구현

**React Flow (XYFlow)**를 기반으로 드래그-앤-드롭 워크플로우 에디터를 구축합니다. 비개발자도 사용 가능하도록 **템플릿 우선 접근법**과 **자연어 → 워크플로우 변환**을 제공합니다.

```typescript
// 워크플로우 직렬화 스키마
interface WorkflowDefinition {
  id: string;
  version: string;
  name: string;
  
  nodes: {
    id: string;
    type: 'trigger' | 'action' | 'condition' | 'loop';
    position: { x: number; y: number };
    data: {
      label: string;
      config: Record<string, any>;
      inputMapping?: Record<string, string>;
    };
  }[];
  
  edges: {
    id: string;
    source: string;
    target: string;
    condition?: string;
  }[];
  
  inputs: { key: string; type: string; required: boolean }[];
}
```

**극단적 단순화 전략**:
1. **원클릭 템플릿**: "네이버 블로그 발행", "인보이스 다운로드" 등 사전 구축된 워크플로우
2. **자연어 입력**: "아마존에서 무선 마우스 검색해서 상위 5개 가격 추출해줘" → 자동 워크플로우 생성
3. **Record & Replay**: 사용자가 브라우저에서 수동 조작하면 AI가 관찰하고 재사용 가능한 워크플로우 생성

---

## 기술 스택 권장안

| 레이어 | 기술 | 선정 근거 |
|--------|------|----------|
| **워크플로우 UI** | React 18 + React Flow Pro | 프로덕션급 노드 에디터, 상용 지원 |
| **상태 관리** | Zustand + React Query | 경량, TypeScript 친화적 |
| **오케스트레이션** | FastAPI (Python) | Skyvern 패턴 호환, 비동기 우수 |
| **브라우저 제어** | Playwright + MCP | 크로스 브라우저, AI 통합 |
| **로컬 LLM** | Ollama + Qwen2.5-VL-7B | 한국어 OCR, 무료, 8GB VRAM |
| **클라우드 LLM** | Claude Sonnet 4 (주), GPT-4o (폴백) | 비용 대비 성능 최적 |
| **큐/캐시** | Redis + BullMQ | 분산 태스크 큐, 세션 캐싱 |
| **DB** | PostgreSQL | 워크플로우/세션 영속화 |
| **모니터링** | Prometheus + Grafana | 메트릭 수집, 대시보드 |

---

## 구현 로드맵

### Phase 1: 기반 구축 (4주)
- Stagehand 3.0 통합 및 act/extract/observe 래퍼 구현
- Playwright MCP 서버 설정 및 커스텀 도구 추가
- Ollama + Qwen2.5-VL 로컬 배포
- 15개 Atomic Block 기본 구현

### Phase 2: Vision + 하이브리드 LLM (3주)
- Screenshot → Vision → Action 파이프라인 완성
- HybridLLMRouter 구현 및 Fallback Chain 설정
- 네이버 도메인 특화 라우팅 규칙 튜닝

### Phase 3: 프로덕션 안정화 (3주)
- Browser Pool + 세션 영속성 구현
- 봇 탐지 회피 (Human-like delays, 프록시 풀)
- Circuit Breaker + 스크린샷 기반 디버깅

### Phase 4: 워크플로우 빌더 (4주)
- React Flow 기반 UI 에디터 구현
- 템플릿 라이브러리 (네이버 블로그 5종)
- 자연어 → 워크플로우 변환 (GPT-4o 기반)
- 워크플로우 저장/공유/버전관리

---

## 리스크 분석과 트레이드오프

| 리스크 | 영향도 | 완화 전략 |
|--------|--------|----------|
| **네이버 봇 탐지 강화** | 높음 | 가우시안 딜레이, 한국 주거용 프록시, 계정별 핑거프린트 고정 |
| **Qwen2.5-VL 한국어 OCR 오류** | 중간 | Upstage Document AI 폴백, 신뢰도 임계값(0.8) 적용 |
| **로컬 GPU 부족** | 중간 | 클라우드 Vision API 자동 폴백, RunPod/Vast.ai 온디맨드 |
| **MCP 프로토콜 변경** | 낮음 | 추상화 레이어 유지, Playwright MCP 공식 업데이트 추적 |
| **Stagehand v4 Breaking Changes** | 중간 | 프리미티브 래퍼로 의존성 격리, 버전 고정 |

**핵심 트레이드오프**: DOM 기반(Stagehand)은 빠르고 저렴하지만 시각적 UI에 약하고, Vision 기반은 범용적이지만 느리고 비쌉니다. CareOn은 **DOM 우선 → Vision 폴백** 전략으로 두 장점을 취합니다.

---

## 결론

CareOn의 최적 아키텍처는 **Stagehand의 타입 안전한 DOM 프리미티브**를 기반으로, **Qwen2.5-VL Vision**으로 시각적 UI를 보완하고, **Skyvern 스타일 멀티 에이전트**로 복잡한 워크플로우를 오케스트레이션하며, **Playwright MCP**로 AI 직접 제어를 구현하는 하이브리드 구조입니다. 

로컬/클라우드 LLM 라우팅으로 **월 비용을 $150에서 $25로 절감**하면서, React Flow 기반 비주얼 빌더로 **비개발자도 커스텀 자동화 시나리오를 구성**할 수 있습니다. 14주 로드맵을 통해 프로덕션급 네이버 블로그 자동화 시스템을 구축할 수 있으며, 이 아키텍처는 향후 다른 한국 플랫폼(카카오, 쿠팡 등)으로 확장 가능합니다.